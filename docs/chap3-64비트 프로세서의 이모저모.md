# 64비트 프로세서의 이모저모

- 64비트 프로세서의 내부 구조
- 운영모드별 메모리 관리 기법의 공통점, 차이점
- 모드를 전환할때 필요한 초기화들.

## 운영모드

| 운영 모드     | 설명                                       |
| --------- | ---------------------------------------- |
| 리얼 모드     | 프로세서의 초기 상태로서 16비트 모드로 동작하여 8086프로세서와 호환되는 모드. 최대 1MB(2^20)의 주소 공간 지원 |
| 보호 모드     | 32비트 모드로 동작하여 세그먼트, 페이징 , 보호, 멀티태스킹등의 기능을 제공하는 모드. 최대 4GB(2^32)의 주소 공간 지원 |
| IA-32e 모드 | 32비트 호환 모드와 64비트 모드의 두 가지 서브모드로 구성. 16EB(2^64)의 주소 공간 지원 |
| 가상 8086모드 | 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드  |
| 시스템 관리 모드 | 전원 관리나 하드웨어 제어같은 특수 모드를 제공하는 모드          |

- 컨트롤 레지스터와 인터럽트라는 특수한 이벤트를 통해 모드전환.
- 여기서 OS가 갖추어야 할 필수 운영 모드는 **리얼 모드**, **보호 모드**, **IA-32e 모드**가 있음.

### 리얼 모드

- 전원이 켜지거나 리셋되면 기본적으로 진입하는 모드.
- 16비트 프로세서와 동일하게 동작
- BIOS의 여러 기능 사용가능.
  - BIOS는 디스크 읽기, 쓰기 기능, 그래픽 모드로 전환하는 기능등 여러 기능을 제공함.
  - 이를 통해서 별도의 디바이스 드라이버를 제작하지 않고도 원하는 작업 수행가능.
- 리얼 모드에서 하는 작업은 OS이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경하는것임.
  - 이 작업은 어셈블리로 처리함.

### 보호 모드

- 리얼모드에서 IA-32e모드로 전환하기 위해서 거쳐가야 함.
- OS가 동작하는 기본 모드.
- 최대 4GB의 주소 공간 제공.
- 페이징, 멀티태스킹,보호, 세그먼테이션들의 기능을 하드웨어적으로 지원함.

### IA-32e 모드

- 서브모드로 32비트 호환 모드와 64비트 호환 모드가 있음.
  - 32비트 호환 모드는 보호 모드와 같은 기능을 수행.
- 주로 사용할 모드
- 대부분의 자료구조는 보호모드와 같거나 크기만 2배로 확장되고 일부 필드의 의미가 변하는 정도의 차이점이 있음.
- 32비트 코드를 그대로 실행가능.
  - 서브모드를 변경함으로써 가능.

### 각 모드의 관계와 운영 모드의 전환

![mode](http://cfile1.uf.tistory.com/image/2469144053298C4618E6C0)

- 각 모드에 필요한 자료구조는 미리 설정되어있어야 함.

## 운영모드와 레지스터

보호모드는 아래와 같은 레지스터들을 갖고있다.

- 프로그램 실행에 관련된 기본 레지스터
  - 범용 레지스터
  - 인스트럭션 포인터 레지스터
  - 16비트 세그먼트 레지스터
- 실수연산, SIMD 관련 레지스터
  - FPU레지스터 - 80bit
  - MMX레지스터 - 64bit
  - XMM레지스터 - 128bit
- 시스템 관련 레지스터
  - 컨트롤 레지스터
  - 플래그 레지스터
  - 글로벌 디스크립터 테이블 레지스터
  - 인터럽트 디스크립터 테이블 레지스터
  - 로컬 디스크립터 테이블 레지스터
  - 태스크 레지스터
  - 모델 고유 레지스터

IA-32e 모드와 보호모드 둘다 크기의 차이와 개수의 차이밖에 없기때문에 생략.

여기서 주로 알아볼 레지스터는 **범용 레지스터**,**세그먼트 레지스터**,**컨트롤 레지스터** 정도다.

### 범용 레지스터

- 계산, 메모리 어드레스 지정, 임시 저장 공간,등등…. 다양한 목적으로 사용.
- 범용 레지스터의 수는 프로세서가 지원하는 운영 모드에 따라 다름.
  - 16비트, 32비트 모드를 지원하는 x86에서는 8개, 64비트 모드를 지원하는 x86-64 계열은 16개의 범용 레지스터가 있음.
- 많을수록 메모리에 덜 접근하고 작업을 처리할 수 있기때문에 속도가 더 빠름.
- 아래는 범용 레지스터의 용도이다.

| 범용 레지스터 이름 | 용도                                       |
| ---------- | ---------------------------------------- |
| AX         | 산술 연산을 수행할때 누산기로 사용                      |
| BX         | 데이터의 어드레스를 지정할때 데이터 포인터로 사용              |
| CX         | 루프 또는 문자열의 카운터로 사용                       |
| DX         | I/O 어드레스를 지정할 때 사양되며, 산술 연산을 수행할 때 보조 레지스터로 사용 |
| SI         | 문자열에 관련된 작업을 수행할 때 원본 문자열의 인덱스로 사용       |
| DI         | 문자열에 관련된 작업을 수행할 때 목적지 문자열의 인덱스로 사용      |
| Sp         | 스택의 포인터로 사용                              |
| BP         | 스택의 데이터에 접근할 때 데이터의 포인터로 사용              |
| R8-R15     | 아무데나 쓰셈                                  |

- 범용 레지스터의 크기도 운영모드에 따라서 다름.
  - 그러면 각 모드별로 개별적으로 레지스터를 가지고있어야 하지만, 실제로 x86-64 프로세서는 64비트 범용 레지스터만 존재하고, 이를 모드별로 일부 영역만 사용하도록 처리하고 있음.
    - 하위 32비트, 16비트, 8비트의 크기로 구분하여 접근할수있음. 
    - 접두사에 R이 붙으면 64비트, E가 붙으면 32비트, 안붙으면 16비트, 끝자리가 H라면 하위 16비트의 상위 8비트,L이라면 하위 16비트의 하위 8비트다.

![](https://www.tortall.net/projects/yasm/manual/html/arch-x86/x86-registers.png)

- 모드별 접근 가능한 레지스터

  - 리얼 모드: 8비트 레지스터, 16비트 레지스터,32비트 레지스터(사실상 16비트)
    - 32비트 레지스터는 오퍼랜드 크기 접두사 또는 어드레스 크기 접두사를 사용하여 접근가능.
    - 주로 리얼-> 보호모드로 전환하는것처럼 특수한 상황때만 사용
  - 보호모드: 8비트,16비트, 32비트 레지스터
    - 32비트 이하는 리얼 모드처럼 오퍼랜드 크기 접두사와 오퍼랜드 크기 접두사 사용.
  - IA-32e: 8,16,32,64비트 레지스터
    - 기존 두가지 접두사와 새로 추가된 REX 접두사를 사용해서 접근가능.

  |                      | 리얼 모드       | 보호 모드       | IA-32e 모드               |
  | :------------------- | ----------- | ----------- | ----------------------- |
  | Rex 접두사 - IA-32모드 전용 | X   X  X  X | X X X X     | N N N N Y Y Y Y         |
  | 오퍼랜드 크기 접두사          | N  N  Y  Y  | N N Y Y     | N N Y Y N N Y Y         |
  | 어드레스 크기 접두사          | N  Y  N  Y  | N Y N Y     | N Y N Y N Y N Y         |
  | 유효한 오퍼랜드 크기(단위:비트)   | 16 16 32 32 | 32 32 16 16 | 32 32 16 16 64 64 64 64 |
  | 유효한 어드레스 크기(단위: 비트)  | 16 32 16 32 | 32 16 32 16 | 64 32 64 32 64 32 64 32 |

  - 여기서 IA-32e 모드의 기본 오퍼랜드 크기가 32비트로 표시된것을 볼수있음. IA-32e모드의 64비트 서브모드는 64비트 모드인데 그러면 오퍼랜드의 크기와 어드레스의 크기가 모드 64비트여야 되는거 아닌가?
  - 이때문에 64비트 어드레스를 표현할수 없으므로 RIP 상대 어드레스라는 새로운 어드레스 계산 방식이 도입됨.

- RIP 레지스터는 32비트 오퍼랜드 크기를 가지고있기때문에 상위 2G, 하위 2G 범위까지만 표현가능함.

- 범위를 벗어나는 어드레스는 프로세서가 점프문에 예외를 두었는데, 분기 명령어에서 오퍼랜드의 크기는 기본 64비트로 하여 전체 어드레스 범위에서 이동할수 있게 했음.

![](http://jsandroidapp.cafe24.com/xe/files/attach/images/115/517/%5B%EA%B7%B8%EB%A6%BC%203-5%5D.png)

## 세그먼트 레지스터

- 16비트 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할을 함.
- 모드마다 조금씩 역할에 차이가 있음
  - 리얼 모드: 단순히 고정된 크기의 어드레스 영역을 지정하는 역할
  - 보호모드,IA-32e 모드: 접근 권한, 세그먼트의 시작 어드레스와 크기 지정

| 세그먼트 레지스터 이름 | 설명                                       |
| ------------ | ---------------------------------------- |
| CS           | - 코드 영역을 가리키는 레지스터. 데이터 이동 명령으로 값을 변경할수 없으며, 점프 명령이나 인터럽트 관련 명령으로 변겅 가능 |
| DS,ES,FS,GS  | 데이터 영역을 가리키는 레지스터 <br/> 데이터 이동 명령으로 값을 변경할수 있음 <br/> DS 레지스터는 데이터 영역에 접근할 때 암시적으로 사용됨 <br/> ES 레지스터는 문자열과 관련된 작업을 처리할 때 암시적으로 사용됨. <br/>데이터 영역에 접근하면서 DS레지스터 이외의 세그먼트 레지스터를 사용하려면 세그먼트 레지스터 접두사 사용 |
| SS           | 스택 ㅇ역을 가리키는 레지스터 <br/> 데이터 이동 명령으로 값을 변경할수있음 <br/> 스택 관련 레지스터를 통해 스택에 접근할때 암시적으로 사용. |

(x86-64 기준)

- 기본적으로 지정하지 않으면 위 표와 같은 레지스터를 사용함.
- 세그먼트 레지스터 접두사를 통해 직접 세그먼트 레지스터 지정가능
  - 스택 작업을 할때 SS가 아닌 CS를 사용하게 만들수있음.
- 세그먼테이션 기법과 관련된 레지스터.

### 컨트롤 레지스터

- 운영 모드를 변경하고 현재 운영중인 모드의 특정 기능을 제어하는 레지스터.
- x86에서는 CR0~CR4까지 5개가, x86-64에서는 CR0~CR4, CR8까지 6개가 존재.

| 컨트롤 레지스터 | 설명                                       |
| -------- | ---------------------------------------- |
| CR0      | - 운영모드를 제어하는 레지스터<br/>-리얼 모드에서 보호 모드로 전환하는 역할과, 캐시,페이징 기능을 활성화시킴. |
| CR1      | - 프로세서에 의해 예약된 레지스터                      |
| CR2      | - 페이지 폴트 발생시 페이지 폴트가 발생한 선형 주소가 저장되는 레지스터<br/>- 페이징 기법을 활성화한 후에는 페이지 폴트 발생 시만 유효한 값을 가짐 |
| CR3      | - 페이지 디렉터리의 물리 주소와 페이지 캐시에 관련된 기능을 설정하는 레지스터 |
| CR4      | - 프로세서에서 지원하는 각종 확장 기능을 제어하는 레지스터<br/>- 페이지 크기 확장이나 메모리 영역 확장등의 기능을 활송화시킴 |
| CR5      | - 태스크 우선순위 레지스터의 값을 제어하는 레지스터<br/>-IA-32e 모드에서만 접근 가능 |

- 리얼 모드와 보호모드일때 모드 32비트 크기임.
- IA-32e모드일때는 64비트 크기지만 일부 제약 사항이 있음.
  - CR0,CR4,CR8 레지스터는 64비트중 상위 32바이트를 0으로 설정해야함.
  - CR2는 모두 사용가능
  - CR3 레지스터는 비트 40부터 51까지 0으로 설정해야함.
- 다른 레지스터에 비해 복잡한 구조를 가짐.
- 컨트롤레지스터의 특정 기능은 해당 비트를 1로 만드는것으로도 충분하지만, 어떤 기능은 그 기능을 사용하기전 사용할 자료구조를 미리 준비해놔야됨.
  - 안하면 펑!
  - CP0의 비트 0값을 변경하거나 아무거나 바꿔보면 재부팅됨
    - 비트 0은 리얼모드와 보호모드를 전환하는 Flag이며, 값을 변경하기 전후에 별도로 처리해야하는 대표적인 예임.

![](http://thumbnail.egloos.net/600x0/http://pds27.egloos.com/pds/201301/14/54/b0159254_50f388d25ea89.png)

- 회색은 예약된 비트.

## 운영모드와 메모리 관리 기법

- 크게 세그먼테이션과 페이징으로 나눌수있음.
- 세그먼테이션: 전체 역역을 원하는 크기로 나누어 관리하는 방식
- 페이징: 일정한 단위로 잘라진 조각을 모아 원하는 크기로 관리하는 방식
- 메모리 관리 기법을 사용하려면 특정한 자료구조를 설정해야함
  - 세그먼테이션: 세그먼트 레지스터에 세그먼트의 시작주소나 디스크립터라고 불리는 자료구조의 위치를 설정해야함.
  - 페이징: CR3레지스터에 페이지 디렉터리라고 불리는 자료구조의 물리 주소를 설정해야 사용할수있음.
- 운영모드에 따라서 특정 기능이 제한되거나 지원을 안하기도함.

### 리얼 모드의 메모리 관리 방식

- 최대 1MB까지 주소공간을 사용하며, 세그먼테이션만 지원. 페이징 X.
- 세그먼트 크기는 64k로 고정.
- 시작 어드레스는 세그먼트 레지스터에 직접 지정
- 세그먼트의 시작 어드레스는 코드나 메모리에 접근할때 Base address(기준 주소)로 사용됨.
- 아래 그림은 세그먼트 레지스터와 세그먼트, 물리주소의 관계다.

![Real_segmentation](http://cfile25.uf.tistory.com/image/2463E140543BAEB20F913F)

- 1MB까지의 영역을 모두 표현하기 위해 세그먼트 레지스터의 값에 16곱한값을 세그먼트의 기준 주소로 사용함. 이 값에 범용 레지스터를 더한 값이 실제 물리주소가 됨.(범용 레지스터도 16비트)
  - 16비트의 최댓값은 65535(2^16-1)인데 여기에 16을 곱하면 1048560(2^20-16)으로 1MB에 근접해진다.
- 세그먼트의 크기가 64kb인 이유는 범용 레지스터의 크기가 16비트인데(리얼 모드니까), 16비트의 최댓값이 0xffff(65535)이므로 세그먼트 크기도 64kb가 된것임.
- 보호모드도 이와 같이 세그먼트의 기준주소와 범용 레지스터를 더해서 계산하지만, 페이징때문에 물리 주소로 바로 바뀌는것이 아닌, 선형 주소라는 논리 주소로 바뀐다. 선형 주소는 페이징을 거쳐서 물리 주소로 바뀌게된다.

### 보호 모드의 메모리 관리 방식

- 세그먼테이션과 페이징을 모두 지원.

- 보호모드의 세그먼테이션은 리얼 모드의 세그먼테이션과 달리 권한과 같은 여러 기능을 추가로 지원함.

  - 또, 리얼 모드와는 달리 세그먼트 레지스터에 세그먼트의 기준 주소를 직접 설정하는 대신 세그먼트 디스크립터 자료구조의 위치(offset)을 설정하는 방식으로 바뀌었음. 
  - 그래서 세그먼트 레지스터의 명칭도 세그먼트 디스크립터를 선택한다는 의미로 세그먼트 셀렉터로 변경됨.

- 디스크립터는 메모리 영역의 정보를 저장하는 자료구조로 여러 종류가 있음. 그중 세그먼트에 대한 정보를 나타내는 디스크립터를 **세그먼트 디스크립터**라고 함.

  - 세그먼트의 시작 어드레스와 크기, 권한, 타입등의 정보를 담음.

  - 메모리상에 존재함. GDT라고 불리는 곳에 모여있음.

  - 권한(DPL)

    - 0~3까지의 값을 가지며 숫자가 작을수록 권한이 높고, 세그먼트에 접근하려면 현재 수행중인 레벨(CPL)이 적어도 디스크립터에 설정된 권한과 같거나 높아야함. 그렇지 않다면 예외를 발생시킴.

  - ![descriptor](https://www.cs.cmu.edu/~410/doc/segments/segdesc.gif)

    ​

- GDT

  - 연속된 디스크립터의 집합

  - 최대 8192개의 디스크립터를 포함할수있음.

  - 테이블 형태의 자료구조.

  - GDTR(Global Descriptor Table Register)에 이 자료구조의 위치를 알린다.(GDT도 메모리에 존재한 자료구조에 불과하니까.)

    - 16비트 GDT크기 필드와 32비트 기준 주소필드로 구성된 자료구조의 물리 주소를 넘겨받음.

    ![](http://thumbnail.egloos.net/600x0/http://pds18.egloos.com/pds/201106/15/44/a0051744_4df8033d5d5ec.jpg)

- 선형주소계산

  ![](https://i.imgur.com/zqRzFjN.png)

  - 리얼모드와 마찬가지로 세그먼트 레지스터의 기준 주소에 범용 레지스터의 값을 더해서 선형 주소를 구함.
    - 프로세서는 이 선형주소를 기반으로 물리 주소를 계산함.
  - 세그먼트 크기는 해당 세그먼트의 어드레스에 접근할 때 참조하며, 기준 주소에 더해질 값은 세그먼트의 크기를 넘을수없음.
    - 더해지는 값이 세그먼트의 크기를 넘게 된다면 프로세서는 예외를 발생시킴.

  ![](https://i.imgur.com/NBlro41.png)

  - 리얼 모드와 달리 선형주소는 물리 주소와 일치할수도, 그렇지 않을수도 있음.
  - 선형 주소는 이후에 나올 페이징의 입력 값이 됨. 페이징을 사용하지 않는다면 선형주소=물리주소임.
  - 간단한OS를 만들때는 페이징을 사용해도 선형주소와 물리주소는 1:1 대응이 되게 만든다.
    - 메모리 관리 기능을 가볍게 유지할수있고, 메모리 구조가 직관적이여서 디버깅이 쉬워짐.

아래 그림은 세그먼테이션과 페이징을 이용해서 논리 주소를 물리 주소로 변경하는 과정이다.

![](http://pds27.egloos.com/pds/201301/15/54/b0159254_50f4bcce8df14.png)

- 페이징

  - 물리 메모리를 페이지라고 불리는 일정한 크기로 나누고, 선형 주소와 물리 주소를 나눠 놓은 페이지로 연결하는 방식.

  - 물리 메모리 크기보다 더 큰 영역의 선형 주소도 물리 페이지만 연결하면 사용이 가능하므로, 주소 공간을 더 넓게 사용할수있음.

  - 같은 물리 페이지를 여러 선형 주소에 연결함으로써 응용프로그램끼리 공유하는 메모리를 쉽게 처리할수도있음.

  - 독립적인 주소공간을 만들고싶다면, 그냥 페이징 자료구조를 따로따로 생성하고 물리 메모리에 중복되지 않게 연결해주면됨.

    - 최신 OS는 페이징의 이러한 기능을 이용하여 독립된 주소 공간 보장, 공유 메모리, 요구 페이징, 공유 라이브러리등의 기능을 구현하고있음.

    ![](http://cfile24.uf.tistory.com/image/235E7B4E54B7B5D113B49D)

  - 보호모드에서 페이징은 페이지 크기에 따라 크게 두가지로 구분함.

    - 물리 메모리를 4KB 크기로 나누고 3단계로 구분하는 방식. - 여기서 설명할 방법은 이것임.
    - 물리 메모리를 4MB 크기로 나누고 선형 주소를 2단계로 구분하는 방식

  - 3단계 페이징

    - 선형 주소를 디렉터리, 테이블, 오프셋으로 나누며 물리 메모리를 4KB 페이지로 나누어 관리하는 방식

      - 디렉터리: 페이지 디렉터리에 있는 엔트리의 위치

      - 테이블: 페이지 테이블에 있는 엔트리의 위치

      - 페이지 디렉터리와 테이블도 메모리에 있는 자료구조이므로 **CR3 컨트롤 레지스터**를 페이지 디렉터리의 시작 주소로 설정해줘야한다. 이는 페이지 디렉터리 엔터리의 위치 계산에 사용한다.

        - 페이지 디렉터리 엔트리와 페이지 테이블 엔트리는 크기가 모두 4바이트임. 페이지 크기가 최소 4KB 이므로 비트 12~비트 31로 기준 주소를 나타내고 11~0은 속성 필드로 나타냄.

        ![](http://wiki.osdev.org/images/9/9b/Page_table.png)

        - U는 해당 페이지에 접근할수 있는 권한을 나타냄. 0으로 설정하면 유저 어플리케이션 레벨 3을 제외한 모든 레벨에서 접근가능하고, 1로 설정하면 모든 레벨에서 접근이 가능함.
        - 이 기능을 세그먼테이션의 보호기능과 조합해서 메모리 모델을 단순하게 유지하면서 커널 영역과 유저 영역을 구분하는것이 가능해짐.

      - 선형주소는 최상위 비트부터 디렉터리 오프셋 10비트, 테이블 오프셋 10비트, 페이지 오프셋 12비트로 구분함. - 디렉터리와 테이블의 오프셋이 10비트이므로 페이지 디렉터리와 페이지 테이블의 엔트리수는 1024(2^10)개이다.

      - 페이지 오프셋은 12비트이므로 최댓값은 4KB(2^12)이며, 4KB 페이지의 오프셋을 나타내기 위해서다.

      - 페이지 디렉터리 엔트리와 페이지 테이블 엔트리값은 각각 다음에 위치하는 페이지 테이블의 시작 주소와 페이지의 시작 주소를 나타내며 이 값에 선형주소의 오프셋을 더해 물리 주소를 구한다.

      ![](https://i.imgur.com/lobMpgO.png)

      - 정리하면,
        1. CR3 레지스터에 설정된 어드레스로 페이지 디렉터리의 시작 주소를 찾는다.
        2. 페이지 디렉터리의 시작 주소에 선형 주소의 디렉터리 오프셋을 이용하여 해당 디렉터리 엔트리를 찾는다.(디렉터리 엔트리에 설정된 값이 페이지 테이블의 시작 주소).
        3. 페이지 테이블의 시작 주소에 선형 주소의 테이블 오프셋을 이용하여 해당 페이지 테이블 엔트리를 찾는다.(페이지 테이블 엔트리에 설정된 값이 4KB 페이지의 시작 주소)
        4. 페이지의 시작 주소에 선형 주소의 페이지 오프셋값을 더해 실제 물리 주소로 변환한다.

### IA-32e 모드의 메모리 관리

- IA-32e 모드는 두가지 서브 모드(32비트 호환모드, 64비트 모드)가 존재.
  - 여기서 32비트 호환모드는 32비트와 동일하므로 64비트만 설명
- 보호모드와 기본적인 부분은 거의 같음
  - 주소공간이 확장하고 두가지 서브모드를 지원하고 몇가지 기능이 추가된것밖에없음.
  - 큰 차이점 2개를 살펴본다.

1. 세그먼트 디스크립터에 설정된 기준 주소와 크기에 관계 없이 모든 세그먼트가 기준 주소는 0, 크기는 64비트 전체로 설정됨.
   - 이는 보호 모드에서 사용하던 세그먼트 디스크립터가 32비트 어드레스만 저장하게 설계된 탓임.
   - 64비트 어드레스 지원을 위해 디스크립터를 확장하지 않고 강제로 값을 고정함으로서 해결함.
   - == IA-32e 모드에서는 선형 주소를 기준 주소가 다른 여러 개의 세그먼트로 구분할 수 없음을 고려하여 설계해야됨.
2. IA-32e 모드는 호환 모드와 64비트 모드의 두 가지 서브모드를 지원하므로 이를 구분하고자 코드 세그먼트 디스크립터에 L필드(비트21)이 추가됨.
   - 이 필드를 0으로 설정하면 호환모드, 1로 설정하면 64비트 모드로 동작하며, 굳이 보호 모드로 돌아가지 않고도 32비트 코드를 실행할수 있음.
   - 아래 그림은 IA-32모드의 64비트 모드에서 세그먼트 셀렉터, 세그먼트 디스크립터,선형주소의 관계를 표현한것임.

![](http://thumbnail.egloos.net/460x0/http://pds26.egloos.com/pds/201301/15/54/b0159254_50f4de16b9b5b.png)

- 페이징
  - 보호 모드와 달리 주소공간이 64bit로 늘어나므로 기본적으로 PAE 기능이 활성화됨.
  - 4kb 페이징은 5단계로, 2MB페이지는 4단계로 변경됨.
    - 그로 인해서 페이지 맵 레벨 4 테이블(PML4)과 페이지 디렉터리 포인터 테이블(PDPT)가 추가됨.
  - 변환과정은 앞서 설명했던 다른 테이블과 같음.
  - 아래는 4kb 페이지를 가지는 5단계 방식이다.

![](http://pds27.egloos.com/pds/201301/15/54/b0159254_50f4f05bb5345.png)

- 각 테이블의 인덱스가 9비트로 줄어 엔트리의 개수가 512(2^9)개로 줄어들었음.
- 63~48번째 비트는 부호 확장으로 채워졌으므로 사실상 나머지 48비트만 사용한다.
  - 최대 표현 가능한 어드레스는 256TB(2^48)
- 그리고 사용하는 48비트가 모두 사용가능한것은 아니고 각 프로세서에 따라 다르며 프로세서가 40비트의 물리 주소를 지원하는 경우에만 1TB(2^40)의 물리 메모리를 사용할수있음.

![](http://pds26.egloos.com/pds/201301/15/54/b0159254_50f4fa10bb451.png)

- 위 그림을 보면 비트 40에서 51까지는 예약된 비트인것을 볼수있음. 40비트 물리 메모리를 지원하는 프로세서는 주로 서버용 프로세서이므로 PC에 사용하는 프로세서는 보통 1TB 이하만 지원함.
- IA-32e 모드의 페이지 엔트리는 64비트로 늘어난 주소로 인해 8바이트로 늘어남.
- 하위 4바이트는 보호모드와 구조가 같고 상위 4바이트는 기준 주소 필드와 예약된 영역, 임의로 사용 가능한 영역, EXB로 구성됨.
  - 이중 EXB 필드는 해당 페이지에서 명령어가 실행되는것을 막는 필드임. OS를 더 안전하게 만들수있음.

