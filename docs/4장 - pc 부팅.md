# 4장 - pc 부팅

## 부팅과 BIOS

- 부팅: PC가 켜진 후에 OS가 실행되기 전까지 수행되는 일련의 작업 과정
  - 프로세서 초기화(멀티코어 관련 처리 포함)
  - 메모리와 외부 디바이스 검사 및 초기화
  - 부트로더를 메모리에 복사
  - OS를 시작하는 과정까지 포함
  - ...

![](https://i.imgur.com/0JuKV8k.png)

- BIOS
  - 메인보드에 포함된 펌웨어의 일종.
  - 입출력을 담당하는 작은 프로그램
  - PC 메인보드에 ROM이나 플래시 메모리로 존재.
  - 전원이 켜짐과 동시에 프로세서가 가장 먼저 실행하는 코드.
  - 시스템 전반적인 설정값을 관리하는 역할도 함.
  - 설정 값으로 시스템을 초기화하여 OS를 실행함.
  - 디스크 입출력과 비디오 모드 전환등의 기능도 제공함. 이 기능들은 인터럽트를 통해 사용가능.
  - POST과정이 끝난 후 여러 저장장치를 검사하여 부트로더를 찾고, 찾았다면 주소 0x7c00에 복사하고 0x7c00위치에 있는 코드를 실행하게함.
    - 디스크 가장 첫 섹터(512byte)를 읽어 맨 마지막 2바이트가 0x55,0xAA인지 확인함.
      - 만약 아니라면 그 디스크는 부팅 디스크가 아닌걸로 간주한다.
    - 만약 못찾으면 'BIOS Operating Not Found.'와 같은 메시지를 띄워서 알림.
  - 부트로더 이미지를 메모리로 복사함.
- 부트로더
  - BIOS에서 처음으로 제어를 넘겨받는 부분.
  - 저장장치의 가장 앞부분, 즉 가장 첫 번째 섹터 MBR에 존재하는 작은 프로그램임.
    - 섹터(sector): 디스크를 구성하는 데이터의 단위. 하나당 512바이트로 구성됨.
  - OS 실행에 필요한 환경을 설정하고 OS를 메모리에 복사하는게 주 역할임.
  - 크기는 512바이트로 제한되어 있어서 하는 일이 정형화되어있음.
- 파티션
  - 디스크 영역을 논리적으로 구분하는 단위
    - 파티션 영역에 정의된 영역은 독립된 공간을 보장받음.
  - 파티션을 분할하고, 중요한 데이터를 여러곳에 저장하면, 한 파티션에 문제가 발생해도 다른 파티션에서 데이터를 복원할수있음.
  - MBR에는 부트로더에 대한 정보만이 아닌, 디스크의 파티션에 대한 정보도 존재함.
    - MBR에는 4개의 파티션 영역이 있음.

## 구현 개요

### 디렉터리 구조

- Mint64: OS 이미지가 생성되는 최상위 디렉터리
  - 00: bootloader
  - 01.kernel32 : 보호모드 커널
    - Source : 소스파일
    - Temp: 빌드과정에서 생기는 임시 파일
  - 02.kernel64: IA-32e 모드 커널
    - Source: 소스파일
    - Temp: 빌드과정에서 생기는 임시 파일
  - 03.Application : IA-32e 모드 응용프로그램과 관련된 디렉터리
    - 00.HelloWorld : 응용프로그램별 디렉터리
    - ...
  - 04.Utility: OS와 관련된 유틸리티 프로그램
    - 00.ImageMaker: 유틸리티별 디렉터리
    - ...

### Make

-  소스 파일을 이용해서 자동으로 실행 파일, 라이브러리 파일을 만들어주는 유틸리티.
-  소스파일과 목적 파일을 비교한 뒤 마지막 빌드 후에 수정된 파일만 비교하여 빌드를 수행하므로 빌드시간을 단축시켜줌.
-  빌드를 편리하게 해주는 여러 문법과 규칙을 지원.
-  또 귀찮은거 편하게 해줌.
  - 소스파일이 여러개인데 일일이 빌드 명령을 내리면 번거로우니까. 
-  이 프로그램에서는 디렉터리별로 계층관계가 있는 makefile을 구성하고, 이를 통해 OS이미지를 생성하도록 할것임.
  - 운영모드 별로 구분된 디렉터리가 최종 빌드 결과물을 최상위 디렉터리로 복사하고, 최상위 디렉터리의 makefile은 이 결과물을 이용해서 최종적으로 OS 이미지를 생성.
  - 각각의 하위디렉터리에 있는 makefile은 해당 디렉터리의 C언어 파일과 어셈블리어 파일을 자동으로 추출함으로써 더 편리하고 효율적으로 빌드를 수행하도록 할것임.


## 부트로더 제작

- 정상적으로 메모리에 올릴려면 부트섹터 512바이트중 마지막 2바이트를  0x55, 0xAA로만 하면 된다. 간단하다.

### 화면 버퍼와 화면 제어

- 화면에 문자를 출력하려면 비디오 메모리의 어드레스에다 정해진 형식대로 데이터를 채우면 된다.
- 기본 화면 모드는 가로 80문자, 세로 25문자이며, 비디오 메모리 어드레스는 0xb8000부터 시작한다.
- 한 문자는 문자값 1바이트, 속성값 1바이트로 총 2바이트이며, 총 메모리 크기는 80\*25\*2=4000바이트다.

![](http://cfile28.uf.tistory.com/image/2617614D54C0F43B2A6292)

- 하위 4비트의 전경색
- 상위 4비트의 배경색
- 4비트중 최상위는 효과(깜빡임(배경색만 지원), 강조), 나머지 3비트는 색상
- 효과비트의 실제 역할은 비디오 컨트롤러의 속성 모드 제어 레지스터에 따라 결정됨. 속성 모드 제어 레지스터의 Blink 비트를 1로 설정하면 깜빡임 효과가 되며, 0으로 설정하면 배경색 강조 효과가 됨.
  - QEMU에서는 기본으로 배경색 강조 효과로 설정되어 있으며 속성 모드 제어 레지스터이 Blink 비트를 1로 변경해도 깜빡임 효과는 적용되지않음. 따라서 기본적으로 배경색 강조효과로 고장해서 사용함.

![](http://cfile7.uf.tistory.com/image/251FC93854C0F93503FF58)

- 리얼모드의 어드레스 방식은 세그먼트 레지스터에 정의된 기준 주소에 값을 더해 계산함.

  - 따라서 세그먼트 레지스터에 세그먼트의 기준 주소부터 설정해야함.
  - 우리는 세그먼트 레지스터에 0xB800(전 챕터에서 봤듯이 여기에 16을 곱한 후 값을 더해서 주소를 계산함.)를 설정할것임.

  ```assembly
  mov ax, 0xb800
  mov ds, ax
  ```

  - 그리고 []를 이용하면 ds에 접근할수있다.

  ```assembly
  mov byte [0x00], 'M'
  mov byte [0x01], 0x41
  ```

  - 만약 es세그먼트를 기준으로 접근하려면 [es:0x01]로 하면된다.

### 세그먼트 레지스터 초기화

- 부트로더를 실행했을때 세그먼트 레지스터에는 BIOS가 사용했던 값이 들어있음.
  - 세그먼트 레지스터를 초기화하지 않으면 엉뚱한 어드레스에 접근할수 있으므로 초기화 하는게 좋음
- BIOS가 부트 로더를 디스크에서 읽어 메모리에 복사하는 위치가 0x7c00이고, 부트로더의 코드(CS)와 데이터(DS)는 0x7c00부터 512바이트 범위에 존재하므로 CS와 DS세그먼트 레지스터를 모두 0x7c0으로 설정한다.
  - CS는 mov명령으로 처리할수 없고, jmp명령과 세그먼트 레지스터 접두사를 이용해야함.
- ES는 0xB800(비디오 메모리 어드레스)로 초기화
- 자세한건 코드참고 ^^7

### 화면 정리, 부팅 메시지 출력

- 화면이 지저분하므로 0x80\*25\*2바이트를 모두 0으로 채우고 문자를 입력할때 속성값을 지정해주기 귀찮기때문에 속성값은 원하는 색 골라서 문자만 0으로 하고 속성값은 그걸로 초기화하자.
- 어셈짜기 힘들면 C로 짜서 최적화끄고 컴파일해보셈

